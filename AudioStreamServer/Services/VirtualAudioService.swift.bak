//
//  VirtualAudioService.swift
//  AudioStreamServer
//  Created by 0xav10086 on 2025/10/30/00/12.


import Foundation
import AVFoundation
import Combine
import CoreAudio

class AudioCaptureService: NSObject, ObservableObject {
    // MARK: - å‘å¸ƒå±æ€§
    @Published var audioLevel: Double = 0.0
    @Published var isCapturing: Bool = false
    @Published var errorMessage: String?
    @Published var audioFormat: String = "æœªé…ç½®"
    @Published var bufferStatus: String = "ç©ºé—²"
    
    // MARK: - éŸ³é¢‘é…ç½®
    private let targetDeviceNames = ["BlackHole 2ch", "BlackHole"]
    private let bufferSize: AVAudioFrameCount = 1024
    private var audioFormatDesc: AVAudioFormat?
    
    // MARK: - éŸ³é¢‘å¼•æ“ç»„ä»¶
    private var audioEngine: AVAudioEngine?
    
    // MARK: - éŸ³é¢‘æ•°æ®å¤„ç†
    private var audioBufferSubject = PassthroughSubject<Data, Never>()
    var audioDataPublisher: AnyPublisher<Data, Never> {
        audioBufferSubject.eraseToAnyPublisher()
    }
    
    // MARK: - ç»Ÿè®¡ä¿¡æ¯
    private var totalFramesCaptured: Int64 = 0
    private var lastProcessTime: Date?
    private var bufferQueue: [Data] = []
    private let maxBufferQueueSize = 10
    
    // MARK: - éŸ³é¢‘æ ¼å¼å±æ€§
    var sampleRate: Double {
        return audioFormatDesc?.sampleRate ?? 0.0
    }
    
    var channelCount: UInt32 {
        return audioFormatDesc?.channelCount ?? 0
    }
    
    // MARK: - ç”Ÿå‘½å‘¨æœŸ
    override init() {
        super.init()
        setupAudioSession()
        // å»¶è¿Ÿæ‰§è¡Œè®¾å¤‡æ‰«æï¼Œé¿å…åˆå§‹åŒ–æ—¶çš„é—®é¢˜
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            self.listAllAudioDevices()
        }
    }
    
    deinit {
        stopCapture()
    }
    
    // MARK: - å…¬å…±æ–¹æ³•
    func startCapture() throws {
        guard !isCapturing else { return }
        
        do {
            print("ğŸ§ å¼€å§‹éŸ³é¢‘æ•è·...")
            
            // é‡ç½®çŠ¶æ€
            resetCaptureState()
            
            // åˆ›å»ºå¹¶é…ç½®éŸ³é¢‘å¼•æ“
            try setupAudioEngine()
            
            // å¯åŠ¨éŸ³é¢‘å¼•æ“
            try audioEngine?.start()
            
            isCapturing = true
            errorMessage = nil
            bufferStatus = "è¿è¡Œä¸­"
            
            print("âœ… éŸ³é¢‘æ•è·å·²å¯åŠ¨ - æ ¼å¼: \(self.audioFormat)")
            
        } catch {
            let errorMsg = "âŒ å¯åŠ¨éŸ³é¢‘æ•è·å¤±è´¥: \(error.localizedDescription)"
            errorMessage = errorMsg
            bufferStatus = "é”™è¯¯"
            print(errorMsg)
            throw error
        }
    }
    
    func stopCapture() {
        guard isCapturing else { return }
        
        print("ğŸ›‘ åœæ­¢éŸ³é¢‘æ•è·...")
        
        audioEngine?.stop()
        audioEngine?.inputNode.removeTap(onBus: 0)
        audioEngine = nil
        
        isCapturing = false
        audioLevel = 0.0
        bufferStatus = "å·²åœæ­¢"
        bufferQueue.removeAll()
        
        print("âœ… éŸ³é¢‘æ•è·å·²åœæ­¢")
    }
    
    // MARK: - éŸ³é¢‘ä¼šè¯é…ç½®
    private func setupAudioSession() {
        print("âœ… macOS éŸ³é¢‘ä¼šè¯é…ç½®å®Œæˆ")
    }
    
    // MARK: - éŸ³é¢‘å¼•æ“é…ç½®
    private func setupAudioEngine() throws {
        audioEngine = AVAudioEngine()
        
        guard let audioEngine = audioEngine else {
            throw NSError(domain: "AudioCaptureService", code: 1,
                          userInfo: [NSLocalizedDescriptionKey: "æ— æ³•åˆ›å»ºéŸ³é¢‘å¼•æ“"])
        }
        
        let inputNode = audioEngine.inputNode
        
        // é…ç½®è¾“å…¥è®¾å¤‡
        try configureInputDevice(inputNode: inputNode)
        
        // è·å–è¾“å…¥æ ¼å¼
        let inputFormat = inputNode.outputFormat(forBus: 0)
        guard inputFormat.sampleRate > 0 else {
            throw NSError(domain: "AudioCaptureService", code: 2,
                          userInfo: [NSLocalizedDescriptionKey: "è¾“å…¥èŠ‚ç‚¹æ ¼å¼æ— æ•ˆ"])
        }
        
        audioFormatDesc = inputFormat
        updateAudioFormatDisplay()
        
        print("ğŸ›ï¸ éŸ³é¢‘è¾“å…¥æ ¼å¼: \(inputFormat.description)")
        
        // å®‰è£…éŸ³é¢‘æ•è·tap
        installAudioTap(inputNode: inputNode, format: inputFormat)
        
        // è¿æ¥èŠ‚ç‚¹ï¼ˆè™½ç„¶æˆ‘ä»¬ä¸éœ€è¦è¾“å‡ºï¼Œä½†ä¿æŒå¼•æ“è¿è¡Œï¼‰
        audioEngine.connect(inputNode, to: audioEngine.mainMixerNode, format: inputFormat)
        
        // å‡†å¤‡éŸ³é¢‘å¼•æ“
        audioEngine.prepare()
    }
    
    private func configureInputDevice(inputNode: AVAudioInputNode) throws {
        // å°è¯•æŸ¥æ‰¾ BlackHole è®¾å¤‡
        var targetUID: String?
        
        for deviceName in targetDeviceNames {
            if let uid = findTargetDeviceUID(named: deviceName) {
                targetUID = uid
                print("âœ… æ‰¾åˆ°ç›®æ ‡è®¾å¤‡: \(deviceName) (UID: \(uid))")
                break
            }
        }
        
        if let targetUID = targetUID {
            // åœ¨ macOS ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡è®¾ç½®é»˜è®¤è¾“å…¥è®¾å¤‡æ¥å®ç°
            setDefaultInputDevice(to: targetUID)
            print("âœ… æˆåŠŸè®¾ç½®è¾“å…¥è®¾å¤‡")
        } else {
            print("âš ï¸ æœªæ‰¾åˆ° BlackHole è®¾å¤‡ï¼Œä½¿ç”¨ç³»ç»Ÿé»˜è®¤è¾“å…¥")
            print("ğŸ’¡ è¯·ç¡®ä¿ï¼š")
            print("   1. BlackHole å·²æ­£ç¡®å®‰è£…")
            print("   2. åœ¨ç³»ç»Ÿè®¾ç½®ä¸­å°† BlackHole è®¾ä¸ºè¾“å‡ºè®¾å¤‡")
            print("   3. é‡å¯åº”ç”¨æˆ–ç”µè„‘")
        }
    }
    
    private func setDefaultInputDevice(to deviceUID: String) {
        let deviceID = getDeviceID(from: deviceUID)
        guard deviceID != kAudioObjectUnknown else {
            print("âŒ æ— æ³•è·å–è®¾å¤‡ID")
            return
        }
        
        var propertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDefaultInputDevice,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var targetDeviceID = deviceID
        let status = AudioObjectSetPropertyData(
            AudioObjectID(kAudioObjectSystemObject),
            &propertyAddress,
            0,
            nil,
            UInt32(MemoryLayout<AudioDeviceID>.size),
            &targetDeviceID
        )
        
        if status == noErr {
            print("âœ… é»˜è®¤è¾“å…¥è®¾å¤‡å·²è®¾ç½®")
        } else {
            print("âš ï¸ è®¾ç½®é»˜è®¤è¾“å…¥è®¾å¤‡å¤±è´¥ï¼ŒçŠ¶æ€ç : \(status)")
        }
    }
    
    private func installAudioTap(inputNode: AVAudioInputNode, format: AVAudioFormat) {
        inputNode.installTap(onBus: 0, bufferSize: bufferSize, format: format) { [weak self] (buffer, time) in
            self?.processAudioBuffer(buffer, time: time)
        }
    }
    
    private func processAudioBuffer(_ buffer: AVAudioPCMBuffer, time: AVAudioTime) {
        guard isCapturing else { return }
        
        // æ›´æ–°å¤„ç†æ—¶é—´
        lastProcessTime = Date()
        
        // è®¡ç®—éŸ³é¢‘ç”µå¹³
        calculateAudioLevel(from: buffer)
        
        // è½¬æ¢å¹¶å‘é€éŸ³é¢‘æ•°æ®
        if let audioData = convertToAudioData(buffer: buffer) {
            totalFramesCaptured += Int64(buffer.frameLength)
            audioBufferSubject.send(audioData)
            
            // ç®¡ç†ç¼“å†²åŒºé˜Ÿåˆ—
            manageBufferQueue(audioData)
        }
    }
    
    private func calculateAudioLevel(from buffer: AVAudioPCMBuffer) {
        guard let channelData = buffer.floatChannelData?[0] else { return }
        
        let frameLength = Int(buffer.frameLength)
        var sum: Float = 0.0
        
        for i in 0..<frameLength {
            let sample = channelData[i]
            sum += sample * sample
        }
        
        let rms = sqrt(sum / Float(frameLength))
        let db = 20.0 * log10(rms + 1e-10)
        let normalizedLevel = max(0.0, min(1.0, (db + 60.0) / 60.0))
        
        DispatchQueue.main.async {
            self.audioLevel = Double(normalizedLevel)
        }
    }
    
    private func convertToAudioData(buffer: AVAudioPCMBuffer) -> Data? {
        guard let channelData = buffer.floatChannelData?[0] else { return nil }
        
        let frameLength = Int(buffer.frameLength)
        let dataSize = frameLength * MemoryLayout<Float>.size
        
        return channelData.withMemoryRebound(to: UInt8.self, capacity: dataSize) { pointer in
            return Data(bytes: pointer, count: dataSize)
        }
    }
    
    private func manageBufferQueue(_ audioData: Data) {
        bufferQueue.append(audioData)
        
        // é™åˆ¶é˜Ÿåˆ—å¤§å°
        if bufferQueue.count > maxBufferQueueSize {
            bufferQueue.removeFirst()
        }
        
        // æ›´æ–°ç¼“å†²åŒºçŠ¶æ€
        updateBufferStatus()
    }
    
    private func updateBufferStatus() {
        let status: String
        if bufferQueue.count == 0 {
            status = "ç©ºé—²"
        } else if bufferQueue.count < maxBufferQueueSize / 2 {
            status = "æ­£å¸¸"
        } else {
            status = "ç¹å¿™(\(bufferQueue.count)/\(maxBufferQueueSize))"
        }
        
        DispatchQueue.main.async {
            self.bufferStatus = status
        }
    }
    
    private func updateAudioFormatDisplay() {
        guard let format = audioFormatDesc else {
            audioFormat = "æœªé…ç½®"
            return
        }
        
        audioFormat = "\(Int(format.sampleRate))Hz â€¢ \(format.channelCount)å£°é“ â€¢ 32-bit Float"
    }
    
    private func resetCaptureState() {
        totalFramesCaptured = 0
        lastProcessTime = nil
        bufferQueue.removeAll()
        audioLevel = 0.0
    }
    
    // MARK: - Core Audio è¾…åŠ©å‡½æ•°ï¼ˆå®‰å…¨ç‰ˆæœ¬ï¼‰
    private func getDeviceID(from deviceUID: String) -> AudioDeviceID {
        let devices = getAllAudioDevices()
        for device in devices {
            if device.uid == deviceUID {
                return device.id
            }
        }
        
        print("âŒ æœªæ‰¾åˆ°è®¾å¤‡UID: \(deviceUID)")
        return kAudioObjectUnknown
    }

    private func isInputDevice(_ deviceID: AudioDeviceID) -> Bool {
        var propertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyStreams,
            mScope: kAudioDevicePropertyScopeInput,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var dataSize: UInt32 = 0
        let status = AudioObjectGetPropertyDataSize(
            deviceID,
            &propertyAddress,
            0,
            nil,
            &dataSize
        )
        
        return status == noErr && dataSize > 0
    }

    private func isOutputDevice(_ deviceID: AudioDeviceID) -> Bool {
        var propertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyStreams,
            mScope: kAudioDevicePropertyScopeOutput,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var dataSize: UInt32 = 0
        let status = AudioObjectGetPropertyDataSize(
            deviceID,
            &propertyAddress,
            0,
            nil,
            &dataSize
        )
        
        return status == noErr && dataSize > 0
    }

    // MARK: - è®¾å¤‡ä¿¡æ¯è·å–è¾…åŠ©å‡½æ•°ï¼ˆä½¿ç”¨å®‰å…¨çš„ CChar ç¼“å†²åŒºï¼‰
    private func getDeviceName(_ deviceID: AudioDeviceID) -> String? {
        var propertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioObjectPropertyName,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        // å…ˆè·å–å±æ€§æ•°æ®å¤§å°
        var dataSize: UInt32 = 0
        var status = AudioObjectGetPropertyDataSize(
            deviceID,
            &propertyAddress,
            0,
            nil,
            &dataSize
        )
        
        guard status == noErr, dataSize > 0 else {
            print("âŒ æ— æ³•è·å–è®¾å¤‡åç§°å±æ€§å¤§å°: \(status)")
            return nil
        }
        
        // åˆ†é…é€‚å½“å¤§å°çš„ CChar ç¼“å†²åŒº
        var buffer = [CChar](repeating: 0, count: Int(dataSize) + 1)
        
        status = buffer.withUnsafeMutableBytes { bufferPointer in
            guard let baseAddress = bufferPointer.baseAddress else {
                return OSStatus(-1)
            }
            return AudioObjectGetPropertyData(
                deviceID,
                &propertyAddress,
                0,
                nil,
                &dataSize,
                baseAddress
            )
        }
        
        guard status == noErr else {
            print("âŒ è·å–è®¾å¤‡åç§°å¤±è´¥: \(status)")
            return nil
        }
        
        // å®‰å…¨åœ°å°† C å­—ç¬¦ä¸²è½¬æ¢ä¸º Swift å­—ç¬¦ä¸²
        return String(cString: buffer)
    }

    private func getDeviceUID(_ deviceID: AudioDeviceID) -> String? {
        var propertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyDeviceUID,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        // å…ˆè·å–å±æ€§æ•°æ®å¤§å°
        var dataSize: UInt32 = 0
        var status = AudioObjectGetPropertyDataSize(
            deviceID,
            &propertyAddress,
            0,
            nil,
            &dataSize
        )
        
        guard status == noErr, dataSize > 0 else {
            print("âŒ æ— æ³•è·å–è®¾å¤‡UIDå±æ€§å¤§å°: \(status)")
            return nil
        }
        
        // åˆ†é…é€‚å½“å¤§å°çš„ CChar ç¼“å†²åŒº
        var buffer = [CChar](repeating: 0, count: Int(dataSize) + 1)
        
        status = buffer.withUnsafeMutableBytes { bufferPointer in
            guard let baseAddress = bufferPointer.baseAddress else {
                return OSStatus(-1)
            }
            return AudioObjectGetPropertyData(
                deviceID,
                &propertyAddress,
                0,
                nil,
                &dataSize,
                baseAddress
            )
        }
        
        guard status == noErr else {
            print("âŒ è·å–è®¾å¤‡UIDå¤±è´¥: \(status)")
            return nil
        }
        
        // å®‰å…¨åœ°å°† C å­—ç¬¦ä¸²è½¬æ¢ä¸º Swift å­—ç¬¦ä¸²
        return String(cString: buffer)
    }
    
    private func getAllAudioDevices() -> [(id: AudioDeviceID, name: String, uid: String)] {
        var devices: [(AudioDeviceID, String, String)] = []
        
        var propertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDevices,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var dataSize: UInt32 = 0
        let status = AudioObjectGetPropertyDataSize(
            AudioObjectID(kAudioObjectSystemObject),
            &propertyAddress,
            0,
            nil,
            &dataSize
        )
        
        guard status == noErr, dataSize > 0 else {
            print("âŒ æ— æ³•è·å–éŸ³é¢‘è®¾å¤‡åˆ—è¡¨å¤§å°: \(status)")
            return devices
        }
        
        let deviceCount = Int(dataSize) / MemoryLayout<AudioDeviceID>.size
        var deviceIDs = [AudioDeviceID](repeating: 0, count: deviceCount)
        
        let getStatus = AudioObjectGetPropertyData(
            AudioObjectID(kAudioObjectSystemObject),
            &propertyAddress,
            0,
            nil,
            &dataSize,
            &deviceIDs
        )
        
        guard getStatus == noErr else {
            print("âŒ è·å–éŸ³é¢‘è®¾å¤‡åˆ—è¡¨å¤±è´¥: \(getStatus)")
            return devices
        }
        
        for deviceID in deviceIDs {
            if let name = getDeviceName(deviceID), let uid = getDeviceUID(deviceID) {
                devices.append((deviceID, name, uid))
            }
        }
        
        return devices
    }
        
    // ç®€åŒ–è®¾å¤‡æŸ¥æ‰¾é€»è¾‘
    func findTargetDeviceUID(named name: String) -> String? {
        let devices = getAllAudioDevices()
        
        for device in devices {
            if device.name.lowercased().contains(name.lowercased()) {
                print("âœ… æ‰¾åˆ°åŒ¹é…è®¾å¤‡: \(device.name) -> UID: \(device.uid)")
                return device.uid
            }
        }
        
        print("âŒ æœªæ‰¾åˆ°è®¾å¤‡: \(name)")
        return nil
    }
        
    // MARK: - è®¾å¤‡åˆ—è¡¨è°ƒè¯•
    private func listAllAudioDevices() {
        print("ğŸ” æ‰«ææ‰€æœ‰éŸ³é¢‘è®¾å¤‡...")
        let devices = getAllAudioDevices()
        
        print("ğŸ“‹ æ‰¾åˆ° \(devices.count) ä¸ªéŸ³é¢‘è®¾å¤‡:")
        for device in devices {
            let isInput = isInputDevice(device.id)
            let isOutput = isOutputDevice(device.id)
            let type = isInput && isOutput ? "è¾“å…¥/è¾“å‡º" : (isInput ? "è¾“å…¥" : (isOutput ? "è¾“å‡º" : "æœªçŸ¥"))
            print("   - \(device.name) [\(device.uid)] - \(type)")
        }
    }
}

// MARK: - Core Audio å¸¸é‡
private let kAudioObjectSystemObject: AudioObjectID = 1
private let kAudioHardwarePropertyDevices: AudioObjectPropertySelector = 0x64657623 // 'dev#'
private let kAudioDevicePropertyStreams: AudioObjectPropertySelector = 0x73747223 // 'str#'
private let kAudioObjectPropertyName: AudioObjectPropertySelector = 0x6E616D65 // 'name'
private let kAudioDevicePropertyDeviceUID: AudioObjectPropertySelector = 0x75696420 // 'uid '
private let kAudioDevicePropertyScopeInput: AudioObjectPropertyScope = 0x696E7075 // 'inpu'
private let kAudioDevicePropertyScopeOutput: AudioObjectPropertyScope = 0x6F757470 // 'outp'
private let kAudioObjectPropertyScopeGlobal: AudioObjectPropertyScope = 0x676C626C // 'glbl'
private let kAudioObjectPropertyElementMain: AudioObjectPropertyElement = 0
private let kAudioHardwarePropertyDefaultInputDevice: AudioObjectPropertySelector = 0x64696E20 // 'din '
private let kAudioObjectUnknown: AudioDeviceID = 0
